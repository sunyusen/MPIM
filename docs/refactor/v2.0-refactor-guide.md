# MPIM v2.0 重构操作指南

## 文档说明

本文档提供详细的 v2.0 分支创建、开发、提交、合并的完整操作流程。

---

## 一、创建 v2.0 分支的操作步骤

### 1.1 前置准备

**清理当前工作区:**

```bash
# 查看当前状态
git status

# 如果有未提交的修改,需要处理
# 方案1: 提交修改
git add .
git commit -m "chore: cleanup before v2.0 branch"

# 方案2: 暂存修改
git stash save "work in progress"

# 方案3: 放弃修改 (谨慎使用!)
git checkout -- .
git clean -fd
```

**清理历史文件 (.history):**

```bash
# 当前有很多 .history 文件被删除但未提交
# 建议一次性清理
git add -u  # 添加所有删除的文件
git commit -m "chore: remove .history files"

# 将 .history 加入 .gitignore 避免再次提交
echo ".history/" >> .gitignore
git add .gitignore
git commit -m "chore: add .history to .gitignore"
```

### 1.2 为当前版本打标签 (备份)

```bash
# 为当前 main 分支打标签作为 v1.0 版本
git tag -a v1.0.0 -m "MPIM v1.0.0 - Production version before v2.0 refactor"

# 推送标签到远程
git push origin v1.0.0

# 查看标签
git tag -l
```

**标签的作用:**
- 作为 v1.0 的版本快照
- 如果 v2.0 重构失败,可以随时回退到这个标签
- 便于对比 v1.0 和 v2.0 的差异

### 1.3 创建备份分支 (可选,额外保险)

```bash
# 从当前 main 创建备份分支
git branch legacy-v1.0

# 推送备份分支到远程
git push origin legacy-v1.0

# 查看所有分支
git branch -a
```

### 1.4 创建 v2.0 分支

```bash
# 从 main 分支创建 v2.0 分支
git checkout -b refactor/v2.0

# 或者使用更详细的命名
git checkout -b refactor/v2.0-architecture-optimization

# 确认当前分支
git branch
# 输出: * refactor/v2.0
```

### 1.5 推送 v2.0 分支到远程

```bash
# 推送新分支到远程仓库
git push -u origin refactor/v2.0

# -u 参数设置上游分支,后续可以直接 git push
```

### 1.6 在 GitHub 上设置分支保护 (推荐)

登录 GitHub,进入仓库设置:

1. **Settings** -> **Branches** -> **Add branch protection rule**
2. **Branch name pattern**: `refactor/v2.0`
3. 勾选保护选项:
   - ✅ Require pull request reviews before merging (需要 PR 审查)
   - ✅ Require status checks to pass (需要 CI 通过)
   - ✅ Include administrators (管理员也遵守规则)

**作用:** 防止误操作直接推送到 v2.0 分支,强制使用 PR 流程。

---

## 二、v2.0 分支开发工作流

### 2.1 日常开发流程

#### Step 1: 更新本地 v2.0 分支

```bash
# 切换到 v2.0 分支
git checkout refactor/v2.0

# 拉取最新代码
git pull origin refactor/v2.0
```

#### Step 2: 创建功能分支 (推荐)

为每个具体任务创建独立的功能分支:

```bash
# 从 v2.0 分支创建功能分支
git checkout -b feature/rpc-connection-pool

# 命名规范:
# feature/xxx  - 新功能
# fix/xxx      - bug 修复
# refactor/xxx - 重构
# docs/xxx     - 文档
```

#### Step 3: 开发和提交

```bash
# 修改代码...

# 查看修改
git status
git diff

# 添加修改
git add path/to/file

# 提交 (遵循 Conventional Commits 规范)
git commit -m "feat(rpc): implement connection pool for RPC calls

- Add ConnectionPool class with RAII wrapper
- Support min/max idle connections configuration
- Implement automatic health check and cleanup
- Add unit tests for connection pool

Closes #123"

# 提交信息规范:
# feat: 新功能
# fix: bug 修复
# refactor: 重构
# docs: 文档
# test: 测试
# chore: 构建/工具配置
```

#### Step 4: 推送到远程

```bash
# 推送功能分支到远程
git push origin feature/rpc-connection-pool
```

#### Step 5: 创建 Pull Request

1. 在 GitHub 上打开仓库
2. 点击 "**Compare & pull request**"
3. **Base**: `refactor/v2.0` (目标分支)
4. **Compare**: `feature/rpc-connection-pool` (源分支)
5. 填写 PR 描述:

```markdown
## 功能描述
实现 RPC 连接池,减少连接建立开销,提升性能

## 变更内容
- 添加 ConnectionPool 类
- 支持连接池配置 (min/max/timeout)
- 实现自动健康检查和清理
- 添加单元测试

## 测试
- [x] 单元测试通过
- [x] 集成测试通过
- [x] 性能测试: RPC QPS 提升 35%

## Checklist
- [x] 代码符合规范
- [x] 添加了测试
- [x] 更新了文档
- [x] 无遗留 TODO

## 相关 Issue
Closes #123
```

6. 点击 "**Create pull request**"
7. 等待 CI 检查和代码审查

#### Step 6: 合并 PR

审查通过后:

```bash
# 在 GitHub 上点击 "Merge pull request"
# 选择合并方式:
# - Create a merge commit (保留完整历史)
# - Squash and merge (合并为一个提交,推荐)
# - Rebase and merge (线性历史)

# 合并后删除功能分支
git branch -d feature/rpc-connection-pool
git push origin --delete feature/rpc-connection-pool
```

### 2.2 同步 main 分支的紧急修复

如果 main 分支有紧急 bug 修复,需要同步到 v2.0:

```bash
# 切换到 v2.0 分支
git checkout refactor/v2.0

# 合并 main 分支的特定提交 (cherry-pick)
git cherry-pick <commit-hash>

# 或者合并整个 main 分支 (如果改动较多)
git merge main

# 解决冲突 (如果有)
git status  # 查看冲突文件
# 手动编辑冲突文件...
git add <resolved-files>
git commit

# 推送到远程
git push origin refactor/v2.0
```

### 2.3 定期同步和整理

```bash
# 每周执行一次,保持分支整洁

# 1. 清理已合并的本地分支
git branch --merged | grep -v "\\*" | grep -v main | grep -v refactor/v2.0 | xargs -n 1 git branch -d

# 2. 清理远程已删除的分支引用
git fetch --prune

# 3. 查看分支情况
git branch -a
```

---

## 三、v2.0 重构的提交规范

### 3.1 提交信息规范 (Conventional Commits)

**格式:**

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型 (type):**
- `feat`: 新功能
- `fix`: bug 修复
- `refactor`: 重构 (不改变外部行为)
- `perf`: 性能优化
- `docs`: 文档
- `test`: 测试
- `chore`: 构建、工具、依赖
- `style`: 代码格式 (不影响逻辑)

**作用域 (scope):**
- `rpc`: RPC 框架
- `gateway`: 网关服务
- `cache`: 缓存层
- `db`: 数据库访问
- `message`: 消息服务
- `config`: 配置管理
- `monitor`: 监控系统

**示例:**

```bash
# 新功能
git commit -m "feat(rpc): add connection pool with configurable size"

# Bug 修复
git commit -m "fix(gateway): fix memory leak in Redis subscription thread"

# 重构
git commit -m "refactor(cache): extract CacheManager from service code"

# 性能优化
git commit -m "perf(db): use prepared statements to reduce SQL parse overhead"

# 文档
git commit -m "docs(refactor): add v2.0 architecture analysis document"
```

### 3.2 提交粒度

**原则: 每个提交应该是一个独立、完整、可编译的单元**

✅ **好的提交:**
```bash
git commit -m "feat(rpc): implement ConnectionPool class"
git commit -m "feat(rpc): add unit tests for ConnectionPool"
git commit -m "feat(rpc): integrate ConnectionPool into MprpcChannel"
```

❌ **不好的提交:**
```bash
git commit -m "WIP: connection pool"  # 工作未完成
git commit -m "fix bugs"               # 太笼统
git commit -m "update"                 # 无意义
```

### 3.3 大型重构的提交策略

对于大型重构 (如服务拆分),分多个 PR 提交:

**阶段 1: 添加新代码 (不影响现有功能)**
```bash
git commit -m "feat(router): add new Router service interface and implementation"
```

**阶段 2: 数据双写 (新旧并存)**
```bash
git commit -m "refactor(presence): add dual-write to new Router service"
```

**阶段 3: 切换读流量 (灰度)**
```bash
git commit -m "refactor(presence): gradually switch to read from Router service"
```

**阶段 4: 清理旧代码**
```bash
git commit -m "refactor(presence): remove legacy routing logic"
```

---

## 四、v2.0 完成后的合并流程

### 4.1 合并前检查清单

```bash
# 1. 所有计划功能已完成
# 2. 所有测试通过
cd /home/glf/MPIM
./autobuild.sh
cd build && ctest

# 3. 代码审查完成
# 4. 性能测试达标
cd benchmarks
./run_all_benchmarks.sh

# 5. 文档更新完成
# 6. 部署文档准备就绪
```

### 4.2 合并 v2.0 到 main 的两种策略

#### 策略 A: 创建 PR 合并 (推荐,适合团队协作)

```bash
# 1. 确保 v2.0 分支最新
git checkout refactor/v2.0
git pull origin refactor/v2.0

# 2. 合并最新的 main (解决可能的冲突)
git merge main
# 解决冲突...
git push origin refactor/v2.0

# 3. 在 GitHub 创建 PR: refactor/v2.0 -> main
# Base: main
# Compare: refactor/v2.0

# 4. PR 描述模板:
```

```markdown
## MPIM v2.0 架构重构

### 概述
这是 MPIM 项目的重大版本升级,进行了全面的架构重构和性能优化。

### 主要变更
1. **RPC 框架增强**
   - 实现连接池,性能提升 40%
   - 添加负载均衡、熔断、限流机制

2. **服务架构优化**
   - 拆分 im-presence 服务,职责更清晰
   - 新增 im-router 和 im-dispatcher 服务

3. **数据访问层重构**
   - 统一缓存访问层 CacheManager
   - 实现 DAO 模式,提升代码可维护性

4. **可观测性提升**
   - 引入结构化日志
   - 完善监控指标 (Prometheus)
   - 实现分布式追踪

### 性能对比
| 指标 | v1.0 | v2.0 | 提升 |
|------|------|------|------|
| RPC QPS | 26,850 | 42,000 | +56% |
| P99 延迟 | 2.6ms | 1.8ms | -31% |
| 连接数 | 10,000 | 50,000 | +400% |

### 破坏性变更
- 配置文件格式变更 (需要更新部署配置)
- RPC 接口新增参数 (向后兼容)

### 升级指南
请参考 [v2.0 升级文档](docs/refactor/v2.0-upgrade-guide.md)

### 测试
- [x] 单元测试通过 (覆盖率 75%)
- [x] 集成测试通过
- [x] 性能测试达标
- [x] 压力测试通过

### Review 负责人
@reviewer1 @reviewer2
```

```bash
# 5. 等待 CI 和审查通过

# 6. 合并 (选择 Create a merge commit 保留完整历史)
```

#### 策略 B: 直接替换 main (适合个人项目,激进)

```bash
# ⚠️ 警告: 这会重写 main 分支历史,谨慎使用!

# 1. 备份当前 main
git checkout main
git branch backup-main-$(date +%Y%m%d)
git push origin backup-main-$(date +%Y%m%d)

# 2. 用 v2.0 替换 main
git checkout refactor/v2.0
git branch -D main  # 删除本地 main
git checkout -b main  # 从 v2.0 创建新的 main
git push origin main --force  # 强制推送

# ⚠️ 这会导致其他协作者的 main 分支失效,需要通知他们:
```

通知协作者执行:
```bash
git fetch origin
git checkout main
git reset --hard origin/main
```

### 4.3 打 v2.0 版本标签

```bash
# 合并完成后,为 main 分支打 v2.0.0 标签
git checkout main
git pull origin main

git tag -a v2.0.0 -m "MPIM v2.0.0 - Major architecture refactor

Major Changes:
- RPC connection pool (+40% performance)
- Service architecture optimization
- Unified cache and database access layer
- Enhanced observability (structured logging, metrics, tracing)
- Improved reliability (circuit breaker, rate limiter, retry)

See CHANGELOG.md for full details.
"

git push origin v2.0.0
```

### 4.4 清理分支

```bash
# 合并后保留 v2.0 分支一段时间 (以防需要回退)
# 3-6 个月后,如果 v2.0 稳定运行,可以删除分支

# 删除远程 v2.0 分支
git push origin --delete refactor/v2.0

# 删除本地 v2.0 分支
git branch -d refactor/v2.0
```

---

## 五、v2.0 开发过程中的分支管理

### 5.1 分支策略总结

```
main (生产分支)
  ├── v1.0.0 (tag)
  ├── legacy-v1.0 (备份分支)
  │
  └── refactor/v2.0 (重构主分支)
        ├── feature/rpc-connection-pool (功能分支)
        ├── feature/cache-manager (功能分支)
        ├── feature/router-service (功能分支)
        ├── fix/redis-leak (修复分支)
        └── docs/v2.0-guide (文档分支)
```

### 5.2 分支命名规范

| 分支类型 | 命名格式 | 示例 |
|---------|---------|------|
| 主分支 | `main` | `main` |
| 重构分支 | `refactor/<version>` | `refactor/v2.0` |
| 功能分支 | `feature/<description>` | `feature/rpc-connection-pool` |
| 修复分支 | `fix/<description>` | `fix/redis-memory-leak` |
| 文档分支 | `docs/<description>` | `docs/v2.0-architecture` |
| 实验分支 | `experiment/<description>` | `experiment/grpc-migration` |

### 5.3 分支保护策略

```yaml
# .github/branch-protection.yaml (示例配置)
main:
  required_reviews: 2
  require_ci_pass: true
  allow_force_push: false
  
refactor/v2.0:
  required_reviews: 1
  require_ci_pass: true
  allow_force_push: false
```

---

## 六、常见问题和解决方案

### 6.1 问题: v2.0 分支与 main 分支冲突严重

**解决方案:**

```bash
# 定期从 main 合并到 v2.0,及早发现冲突
git checkout refactor/v2.0
git merge main

# 如果冲突太多,考虑 rebase (重写历史,谨慎使用)
git rebase main
```

### 6.2 问题: 功能分支太多,难以管理

**解决方案:**

```bash
# 使用 GitHub Projects 或 Issue 跟踪任务
# 及时合并和删除已完成的功能分支

# 查看所有功能分支
git branch -a | grep feature/

# 批量删除已合并的功能分支
git branch --merged refactor/v2.0 | grep feature/ | xargs git branch -d
```

### 6.3 问题: 提交历史混乱

**解决方案:**

```bash
# 使用 interactive rebase 整理提交历史 (在 push 之前)
git rebase -i HEAD~5

# 在编辑器中:
# pick  - 保留提交
# squash - 合并到上一个提交
# reword - 修改提交信息
# drop  - 删除提交
```

### 6.4 问题: 需要回退到 v1.0

**解决方案:**

```bash
# 方案1: 从标签恢复
git checkout v1.0.0
git checkout -b hotfix/rollback-v2.0
# 部署这个版本...

# 方案2: 从备份分支恢复
git checkout legacy-v1.0
# 部署这个版本...

# 方案3: revert v2.0 的合并提交
git checkout main
git revert -m 1 <merge-commit-hash>
git push origin main
```

---

## 七、自动化脚本

### 7.1 创建功能分支脚本

```bash
#!/bin/bash
# scripts/new-feature.sh

BRANCH_NAME=$1
if [ -z "$BRANCH_NAME" ]; then
    echo "Usage: ./new-feature.sh <feature-name>"
    exit 1
fi

git checkout refactor/v2.0
git pull origin refactor/v2.0
git checkout -b feature/$BRANCH_NAME
echo "Created feature branch: feature/$BRANCH_NAME"
```

### 7.2 提交和推送脚本

```bash
#!/bin/bash
# scripts/commit-and-push.sh

TYPE=$1
SCOPE=$2
MESSAGE=$3

if [ -z "$MESSAGE" ]; then
    echo "Usage: ./commit-and-push.sh <type> <scope> <message>"
    echo "Example: ./commit-and-push.sh feat rpc 'add connection pool'"
    exit 1
fi

git add .
git commit -m "$TYPE($SCOPE): $MESSAGE"
git push origin $(git branch --show-current)
```

### 7.3 同步 main 分支脚本

```bash
#!/bin/bash
# scripts/sync-main.sh

git checkout refactor/v2.0
git pull origin refactor/v2.0
git merge main

if [ $? -ne 0 ]; then
    echo "Merge conflict detected. Please resolve and commit."
    exit 1
fi

git push origin refactor/v2.0
echo "Successfully synced main branch"
```

---

## 八、总结

### v2.0 开发工作流总结

1. **创建分支:** `git checkout -b refactor/v2.0`
2. **日常开发:** 功能分支 -> PR -> 合并到 v2.0
3. **定期同步:** 从 main 同步紧急修复
4. **完成重构:** 创建 PR 合并 v2.0 到 main
5. **打版本标签:** `git tag v2.0.0`

### 最佳实践

- ✅ 小步快跑,频繁提交
- ✅ 每个 PR 只做一件事
- ✅ 提交信息规范化
- ✅ 代码审查不可少
- ✅ 测试先行,持续集成
- ✅ 文档与代码同步更新

### 下一步

- [v2.0 工作清单和时间规划](v2.0-work-roadmap.md) - 查看详细任务分解和排期
- [v2.0 改进方案](v2.0-improvement-plan.md) - 了解技术实现细节

